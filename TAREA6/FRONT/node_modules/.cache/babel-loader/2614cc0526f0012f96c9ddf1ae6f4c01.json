{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachListeners = void 0;\n\nvar socket_io_1 = require(\"./socket-io\");\n\nvar heartbeat_1 = require(\"./heartbeat\");\n\nvar constants_1 = require(\"./constants\");\n\nvar util_1 = require(\"./util\");\n\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage) {\n  var heartbeatCb;\n\n  if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n    var heartbeatOptions = typeof optionsRef.current.heartbeat === \"boolean\" ? undefined : optionsRef.current.heartbeat;\n    heartbeatCb = (0, heartbeat_1.heartbeat)(webSocketInstance, heartbeatOptions);\n  }\n\n  webSocketInstance.onmessage = function (message) {\n    var _a;\n\n    heartbeatCb === null || heartbeatCb === void 0 ? void 0 : heartbeatCb();\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n\n    if (optionsRef.current.heartbeat && typeof optionsRef.current.heartbeat !== \"boolean\" && ((_a = optionsRef.current.heartbeat) === null || _a === void 0 ? void 0 : _a.returnMessage) === message.data) return;\n    setLastMessage(message);\n  };\n};\n\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount) {\n  webSocketInstance.onopen = function (event) {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(constants_1.ReadyState.OPEN);\n  };\n};\n\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return function () {};\n  }\n\n  (0, util_1.assertIsWebSocket)(webSocketInstance, optionsRef.current.skipAssert);\n  var reconnectTimeout;\n\n  webSocketInstance.onclose = function (event) {\n    var _a;\n\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(constants_1.ReadyState.CLOSED);\n\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n\n      if (reconnectCount.current < reconnectAttempts) {\n        var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ? optionsRef.current.reconnectInterval(reconnectCount.current) : optionsRef.current.reconnectInterval;\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n      }\n    }\n  };\n\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\n\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  var reconnectTimeout;\n\n  webSocketInstance.onerror = function (error) {\n    var _a;\n\n    optionsRef.current.onError && optionsRef.current.onError(error);\n\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), {\n        code: 1006,\n        reason: \"An error occurred with the EventSource: \".concat(error),\n        wasClean: false\n      }));\n      setReadyState(constants_1.ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n        var nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ? optionsRef.current.reconnectInterval(reconnectCount.current) : optionsRef.current.reconnectInterval;\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \".concat(optionsRef.current.reconnectAttempts, \" exceeded\"));\n      }\n    }\n  };\n\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\n\nvar attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, sendMessage) {\n  var setLastMessage = setters.setLastMessage,\n      setReadyState = setters.setReadyState;\n  var interval;\n  var cancelReconnectOnClose;\n  var cancelReconnectOnError;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, optionsRef, setLastMessage);\n  bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount);\n  cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  return function () {\n    setReadyState(constants_1.ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n\nexports.attachListeners = attachListeners;","map":{"version":3,"mappings":"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","names":["bindMessageHandler","webSocketInstance","optionsRef","setLastMessage","heartbeatCb","current","heartbeat","WebSocket","heartbeatOptions","undefined","onmessage","message","onMessage","filter","_a","returnMessage","data","bindOpenHandler","setReadyState","reconnectCount","onopen","event","onOpen","constants_1","OPEN","bindCloseHandler","reconnect","EventSource","skipAssert","reconnectTimeout","onclose","onClose","CLOSED","shouldReconnect","reconnectAttempts","nextReconnectInterval","reconnectInterval","window","setTimeout","onReconnectStop","console","warn","clearTimeout","bindErrorHandler","onerror","error","onError","__assign","code","reason","wasClean","close","retryOnError","attachListeners","setters","sendMessage","interval","cancelReconnectOnClose","cancelReconnectOnError","fromSocketIO","CLOSING","clearInterval","exports"],"sources":["/home/kruiz/TAREAS_SOPES/TAREA6/FRONT/node_modules/react-use-websocket/src/lib/attach-listener.ts"],"sourcesContent":["import { MutableRefObject } from 'react';\nimport { setUpSocketIOPing } from './socket-io';\nimport { heartbeat } from './heartbeat';\nimport {\n  DEFAULT_RECONNECT_LIMIT,\n  DEFAULT_RECONNECT_INTERVAL_MS,\n  ReadyState,\n  isEventSourceSupported,\n} from './constants';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { assertIsWebSocket } from './util';\n\nexport interface Setters {\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\n  setReadyState: (readyState: ReadyState) => void;\n}\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: Setters['setLastMessage'],\n) => {\n  let heartbeatCb: () => void;\n\n  if (optionsRef.current.heartbeat && webSocketInstance instanceof WebSocket) {\n    const heartbeatOptions =\n      typeof optionsRef.current.heartbeat === \"boolean\"\n        ? undefined\n        : optionsRef.current.heartbeat;\n    heartbeatCb = heartbeat(webSocketInstance, heartbeatOptions);\n  }\n\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    heartbeatCb?.();\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    if (\n      optionsRef.current.heartbeat &&\n      typeof optionsRef.current.heartbeat !== \"boolean\" &&\n      optionsRef.current.heartbeat?.returnMessage === message.data\n    )\n      return;\n\n    setLastMessage(message);\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnectCount: MutableRefObject<number>,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(ReadyState.OPEN);\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return () => {};\n  }\n  assertIsWebSocket(webSocketInstance, optionsRef.current.skipAssert);\n  let reconnectTimeout: number;\n\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  let reconnectTimeout: number;\n\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose({\n        ...error,\n        code: 1006,\n        reason: `An error occurred with the EventSource: ${error}`,\n        wasClean: false,\n      });\n\n      setReadyState(ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n    \n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\n        console.warn(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nexport const attachListeners = (\n    webSocketInstance: WebSocketLike,\n    setters: Setters,\n    optionsRef: MutableRefObject<Options>,\n    reconnect: () => void,\n    reconnectCount: MutableRefObject<number>,\n    sendMessage: SendMessage,\n  ): (() => void) => {\n  const { setLastMessage, setReadyState } = setters;\n\n  let interval: number;\n  let cancelReconnectOnClose: () => void;\n  let cancelReconnectOnError: () => void;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(\n    webSocketInstance,\n    optionsRef,\n    setLastMessage,\n  );\n\n  bindOpenHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnectCount,\n  );\n\n  cancelReconnectOnClose = bindCloseHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  cancelReconnectOnError = bindErrorHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  return () => {\n    setReadyState(ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}