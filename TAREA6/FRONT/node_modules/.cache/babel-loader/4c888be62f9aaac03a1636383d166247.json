{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachSharedListeners = void 0;\n\nvar globals_1 = require(\"./globals\");\n\nvar constants_1 = require(\"./constants\");\n\nvar manage_subscribers_1 = require(\"./manage-subscribers\");\n\nvar socket_io_1 = require(\"./socket-io\");\n\nvar heartbeat_1 = require(\"./heartbeat\");\n\nvar bindMessageHandler = function (webSocketInstance, url, heartbeatOptions) {\n  var onMessageCb;\n\n  if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n    onMessageCb = (0, heartbeat_1.heartbeat)(webSocketInstance, typeof heartbeatOptions === 'boolean' ? undefined : heartbeatOptions);\n  }\n\n  webSocketInstance.onmessage = function (message) {\n    onMessageCb === null || onMessageCb === void 0 ? void 0 : onMessageCb();\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (typeof subscriber.optionsRef.current.filter === 'function' && subscriber.optionsRef.current.filter(message) !== true) {\n        return;\n      }\n\n      if (heartbeatOptions && typeof heartbeatOptions !== \"boolean\" && (heartbeatOptions === null || heartbeatOptions === void 0 ? void 0 : heartbeatOptions.returnMessage) === message.data) return;\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nvar bindOpenHandler = function (webSocketInstance, url) {\n  webSocketInstance.onopen = function (event) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      subscriber.reconnectCount.current = 0;\n\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(constants_1.ReadyState.OPEN);\n    });\n  };\n};\n\nvar bindCloseHandler = function (webSocketInstance, url) {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = function (event) {\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      });\n      delete globals_1.sharedWebSockets[url];\n      (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n        var _a;\n\n        if (subscriber.optionsRef.current.shouldReconnect && subscriber.optionsRef.current.shouldReconnect(event)) {\n          var reconnectAttempts = (_a = subscriber.optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            var nextReconnectInterval = typeof subscriber.optionsRef.current.reconnectInterval === 'function' ? subscriber.optionsRef.current.reconnectInterval(subscriber.reconnectCount.current) : subscriber.optionsRef.current.reconnectInterval;\n            setTimeout(function () {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, nextReconnectInterval !== null && nextReconnectInterval !== void 0 ? nextReconnectInterval : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts);\n            console.warn(\"Max reconnect attempts of \".concat(reconnectAttempts, \" exceeded\"));\n          }\n        }\n      });\n    };\n  }\n};\n\nvar bindErrorHandler = function (webSocketInstance, url) {\n  webSocketInstance.onerror = function (error) {\n    (0, manage_subscribers_1.getSubscribers)(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n\n      if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose(__assign(__assign({}, error), {\n          code: 1006,\n          reason: \"An error occurred with the EventSource: \".concat(error),\n          wasClean: false\n        }));\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      }\n    });\n\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nvar attachSharedListeners = function (webSocketInstance, url, optionsRef, sendMessage) {\n  var interval;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = (0, socket_io_1.setUpSocketIOPing)(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n  return function () {\n    if (interval) clearInterval(interval);\n  };\n};\n\nexports.attachSharedListeners = attachSharedListeners;","map":{"version":3,"mappings":"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","names":["bindMessageHandler","webSocketInstance","url","heartbeatOptions","onMessageCb","WebSocket","undefined","onmessage","message","forEach","subscriber","optionsRef","current","onMessage","filter","returnMessage","data","setLastMessage","bindOpenHandler","onopen","event","reconnectCount","onOpen","setReadyState","constants_1","OPEN","bindCloseHandler","onclose","onClose","CLOSED","globals_1","shouldReconnect","reconnectAttempts","_a","nextReconnectInterval","reconnectInterval","setTimeout","reconnect","onReconnectStop","console","warn","bindErrorHandler","onerror","error","onError","EventSource","__assign","code","reason","wasClean","close","attachSharedListeners","sendMessage","interval","fromSocketIO","heartbeat","clearInterval","exports"],"sources":["/home/kruiz/TAREAS_SOPES/TAREA6/FRONT/node_modules/react-use-websocket/src/lib/attach-shared-listeners.ts"],"sourcesContent":["import { sharedWebSockets } from './globals';\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState, isEventSourceSupported } from './constants';\nimport { getSubscribers } from './manage-subscribers';\nimport { MutableRefObject } from 'react';\nimport { HeartbeatOptions, Options, SendMessage, WebSocketLike } from './types';\nimport { setUpSocketIOPing } from './socket-io';\nimport { heartbeat } from './heartbeat';\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  heartbeatOptions?: boolean | HeartbeatOptions\n) => {\n  let onMessageCb: () => void;\n\n  if (heartbeatOptions && webSocketInstance instanceof WebSocket) {\n    onMessageCb = heartbeat(webSocketInstance, typeof heartbeatOptions === 'boolean' ? undefined : heartbeatOptions);\n  }\n\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    onMessageCb?.();\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (\n        typeof subscriber.optionsRef.current.filter === 'function' &&\n        subscriber.optionsRef.current.filter(message) !== true\n      ) {\n        return;\n      }\n\n      if (\n        heartbeatOptions &&\n        typeof heartbeatOptions !== \"boolean\" &&\n        heartbeatOptions?.returnMessage === message.data\n      )\n        return;\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    getSubscribers(url).forEach(subscriber => {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(ReadyState.OPEN);\n    });\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n      getSubscribers(url).forEach(subscriber => {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      });\n      \n      delete sharedWebSockets[url];\n  \n      getSubscribers(url).forEach(subscriber => {\n        if (\n          subscriber.optionsRef.current.shouldReconnect &&\n          subscriber.optionsRef.current.shouldReconnect(event)\n        ) {\n          const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            const nextReconnectInterval = typeof subscriber.optionsRef.current.reconnectInterval === 'function' ?\n              subscriber.optionsRef.current.reconnectInterval(subscriber.reconnectCount.current) :\n              subscriber.optionsRef.current.reconnectInterval;\n\n            setTimeout(() => {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\n            console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n          }\n        }\n      });\n    };\n  }\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose({\n          ...error,\n          code: 1006,\n          reason: `An error occurred with the EventSource: ${error}`,\n          wasClean: false,\n        });\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      }\n    });\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexport const attachSharedListeners = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  optionsRef: MutableRefObject<Options>,\n  sendMessage: SendMessage,\n) => {\n  let interval: number;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url, optionsRef.current.heartbeat);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n\n  return () => {\n    if (interval) clearInterval(interval);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}